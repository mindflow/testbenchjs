import{Map as t,List as e,Logger as s}from"./coreutil_v1.js";class n{constructor(){}provide(t,e=[]){return new Promise(((s,n)=>{s(new t(...e))}))}}class r{static get RUNNING(){return 0}static get SUCCESS(){return 1}static get FAIL(){return-1}constructor(t,e,s){this.state=t,this.className=e,this.functionName=s}}class i{constructor(s,n,r=null){this.resultListener=r,this.objectProvider=n,this.testClassMap=s,this.testObjectMap=new t,this.runSuccessTestList=new e,this.runFailTestList=new e}}class a{runFunction(t,e){}runClass(t){}runAll(){}}const c=new s("TestBench");class o extends a{constructor(e=null,s=null,r=new n){super(),this.logListener=e,this.testClassMap=new t,this.resultListener=s,this.objectProvider=r}addTest(t){if(!(t.testFunctions&&t.testFunctions()instanceof e))throw"A static function called 'testFunctions' must be provided in "+t.name+" which returns a List all the test functions in "+t.name+".prototype";return t.testFunctions().forEach(((e,s)=>{if(!e)throw t.name+".testFunctions() refers to missing functions";return!0}),this),this.testClassMap.set(t.name,t),this}contains(t){return this.testClassMap.contains(t.name)}runAll(){s.listener=this.logListener;let t=new i(this.testClassMap,this.objectProvider,this.resultListener);return this.testClassMap.promiseChain(o.run,t).then((()=>{o.close(t)})).catch((t=>{throw t}))}runClass(t){s.listener=this.logListener;let e=this.testClassMap.get(t),n=new i(this.testClassMap,this.objectProvider,this.resultListener);return o.run(t,e,n).then((()=>{o.close(n)})).catch((t=>{throw t}))}runFunction(t,e){s.listener=this.logListener;let n=this.testClassMap.get(t),r=new i(this.testClassMap,this.objectProvider,this.resultListener);return o.run(t,n,r,e).then((()=>{o.close(r)})).catch((t=>{throw t}))}static run(t,e,s,n=null){return o.printHeader(e.name),o.runFunctionsByClass(e,s,n)}static filter(t,e){return e?t.filter((t=>t===e)):t}static loadObjectByClass(t,e){return new Promise(((s,n)=>{e.testObjectMap.contains(t.name)?s():e.objectProvider.provide(t).then((n=>{e.testObjectMap.set(t.name,n),s()})).catch((t=>{n(t)}))}))}static runFunctionsByClass(t,e,s){return t.testFunctions().promiseChain((n=>s&&n.name!==s?Promise.resolve():new Promise(((s,r)=>{o.runFunction(t,n,s,e)}))),e)}static runFunction(t,e,s,n){o.callResultListener(n,r.RUNNING,t,e),o.loadObjectByClass(t,n).then((()=>{const r=n.testObjectMap.get(t.name);let i=null;try{i=e.call(r),i instanceof Promise||o.reportSuccess(t,e,n)}catch(s){o.reportFailure(t,e,s,n)}i instanceof Promise?i.then((()=>{o.reportSuccess(t,e,n),s()})).catch((r=>{o.reportFailure(t,e,r,n),s()})):s()}))}static reportFailure(t,e,s,n){o.addFail(t,e,n),o.callResultListener(n,r.FAIL,t,e),c.error(o.signature(t,e)+" failed. Reason:"),c.error(s),c.error("")}static reportSuccess(t,e,s){o.addSuccess(t,e,s),o.callResultListener(s,r.SUCCESS,t,e)}static callResultListener(t,e,s,n){t.resultListener&&t.resultListener.call(new r(e,s.name,n?n.name:null))}static addSuccess(t,e,s){s.runSuccessTestList.add(o.signature(t,e))}static addFail(t,e,s){s.runFailTestList.add(o.signature(t,e))}static signature(t,e){return t.name+"."+e.name+"()"}static close(t){try{o.printReport(t)}finally{s.clearListener()}}static printHeader(t){const e="#  Running test: "+t+"  #";let s="";for(let t=0;t<e.length;t++)s+="#";c.info(s),c.info(e),c.info(s),c.info("")}static printReport(t){c.info("###################"),c.info("#   Test Report   #"),c.info("###################"),c.info("");let e=0;t.runSuccessTestList.size()>0&&(c.info("Succeeded:"),t.runSuccessTestList.forEach(((t,s)=>(c.info(e+++". "+t),!0))),c.info(""));let s=0;if(t.runFailTestList.size()>0&&(c.info("Failed:"),t.runFailTestList.forEach(((t,e)=>(c.info(s+++". "+t),!0))),c.info("")),0!=s)throw t.runFailTestList.size()+" Tests failed"}}class l{static assertEquals(t,e){if(t!==e)throw"String Assertion Failed. Expected: '"+t+"' Actual: '"+e+"'"}}class u{static assertTrue(t=!0){if(!t)throw"Boolean assertion failed. Expected true but was "+t}}export{u as AssertBoolean,l as AssertString,n as ObjectProvider,o as TestBench,r as TestClassState,i as TestExecutionContext,a as TestTrigger};
