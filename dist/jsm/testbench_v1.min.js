import{Map,List,Logger}from"./coreutil_v1.js";class AssertBoolean{static assertTrue(t=!0){if(!t)throw"Boolean assertion failed. Expected true but was "+t}}class AssertString{static assertEquals(t,e){if(t!==e)throw"String Assertion Failed. Expected: '"+t+"' Actual: '"+e+"'"}}class ObjectProvider{constructor(){}provide(t,e=[]){return new Promise((n,s)=>{n(new t(...e))})}}class TestClassState{static get RUNNING(){return 0}static get SUCCESS(){return 1}static get FAIL(){return-1}constructor(t,e,n){this.state=t,this.className=e,this.functionName=n}}class TestExecutionContext{constructor(t,e,n=null){this.resultListener=n,this.objectProvider=e,this.testClassMap=t,this.testObjectMap=new Map,this.runSuccessTestList=new List,this.runFailTestList=new List}}class TestTrigger{runFunction(t,e){}runClass(t){}runAll(){}}const LOG=new Logger("TestBench");class TestBench extends TestTrigger{constructor(t=null,e=null,n=new ObjectProvider){super(),this.logListener=t,this.testClassMap=new Map,this.resultListener=e,this.objectProvider=n}addTest(t){if(!(t.testFunctions&&t.testFunctions()instanceof List))throw"A static function called 'testFunctions' must be provided in "+t.name+" which returns a List all the test functions in "+t.name+".prototype";return t.testFunctions().forEach((e,n)=>{if(!e)throw t.name+".testFunctions() refers to missing functions";return!0},this),this.testClassMap.set(t.name,t),this}contains(t){return this.testClassMap.contains(t.name)}runAll(){Logger.listener=this.logListener;let t=new TestExecutionContext(this.testClassMap,this.objectProvider,this.resultListener);return this.testClassMap.promiseChain(TestBench.run,t).then(()=>{TestBench.close(t)}).catch(t=>{throw t})}runClass(t){Logger.listener=this.logListener;let e=this.testClassMap.get(t),n=new TestExecutionContext(this.testClassMap,this.objectProvider,this.resultListener);return TestBench.run(t,e,n).then(()=>{TestBench.close(n)}).catch(t=>{throw t})}runFunction(t,e){Logger.listener=this.logListener;let n=this.testClassMap.get(t),s=new TestExecutionContext(this.testClassMap,this.objectProvider,this.resultListener);return TestBench.run(t,n,s,e).then(()=>{TestBench.close(s)}).catch(t=>{throw t})}static run(t,e,n,s=null){return TestBench.printHeader(e.name),TestBench.runFunctionsByClass(e,n,s)}static filter(t,e){return e?t.filter(t=>t===e):t}static loadObjectByClass(t,e){return new Promise((n,s)=>{if(e.testObjectMap.contains(t.name))return void n();e.objectProvider.provide(t).then(s=>{e.testObjectMap.set(t.name,s);n()}).catch(t=>{s(t)})})}static runFunctionsByClass(t,e,n){return t.testFunctions().promiseChain(s=>{if(n&&s.name!==n)return Promise.resolve();return new Promise((n,i)=>{TestBench.runFunction(t,s,n,e)})},e)}static runFunction(t,e,n,s){TestBench.callResultListener(s,TestClassState.RUNNING,t,e),TestBench.loadObjectByClass(t,s).then(()=>{const i=s.testObjectMap.get(t.name);let r=null;try{(r=e.call(i))instanceof Promise||TestBench.reportSuccess(t,e,s)}catch(n){TestBench.reportFailure(t,e,n,s)}if(!(r instanceof Promise))return void n();r.then(()=>{TestBench.reportSuccess(t,e,s);n()}).catch(i=>{TestBench.reportFailure(t,e,i,s);n()})})}static reportFailure(t,e,n,s){TestBench.addFail(t,e,s),TestBench.callResultListener(s,TestClassState.FAIL,t,e),LOG.error(TestBench.signature(t,e)+" failed. Reason:"),LOG.error(n),LOG.error("")}static reportSuccess(t,e,n){TestBench.addSuccess(t,e,n),TestBench.callResultListener(n,TestClassState.SUCCESS,t,e)}static callResultListener(t,e,n,s){t.resultListener&&t.resultListener.call(new TestClassState(e,n.name,s?s.name:null))}static addSuccess(t,e,n){n.runSuccessTestList.add(TestBench.signature(t,e))}static addFail(t,e,n){n.runFailTestList.add(TestBench.signature(t,e))}static signature(t,e){return t.name+"."+e.name+"()"}static close(t){try{TestBench.printReport(t)}finally{Logger.clearListener()}}static printHeader(t){const e="#  Running test: "+t+"  #";let n="";for(let t=0;t<e.length;t++)n+="#";LOG.info(n),LOG.info(e),LOG.info(n),LOG.info("")}static printReport(t){LOG.info("###################"),LOG.info("#   Test Report   #"),LOG.info("###################"),LOG.info("");let e=0;t.runSuccessTestList.size()>0&&(LOG.info("Succeeded:"),t.runSuccessTestList.forEach((t,n)=>{LOG.info(e+++". "+t);return!0}),LOG.info(""));let n=0;if(t.runFailTestList.size()>0&&(LOG.info("Failed:"),t.runFailTestList.forEach((t,e)=>{LOG.info(n+++". "+t);return!0}),LOG.info("")),0!=n)throw t.runFailTestList.size()+" Tests failed"}}export{AssertBoolean,AssertString,ObjectProvider,TestBench,TestClassState,TestExecutionContext,TestTrigger};
