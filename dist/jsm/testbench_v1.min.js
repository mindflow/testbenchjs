import{Map as t,List as s,Logger as e}from"./coreutil_v1.js";class r{constructor(){}provide(t,s=[]){return new Promise(((e,r)=>{e(new t(...s))}))}}class n{runFunction(t,s){}runClass(t){}runAll(){}}class i{static get RUNNING(){return 0}static get SUCCESS(){return 1}static get FAIL(){return-1}constructor(t,s,e){this.state=t,this.className=s,this.functionName=e}}class a{constructor(e,r,n=null){this.resultListener=n,this.objectProvider=r,this.testClassMap=e,this.testObjectMap=new t,this.runSuccessTestList=new s,this.runFailTestList=new s}}const c=new e("TestBench");class o extends n{constructor(s=null,e=null,n=new r){super(),this.logListener=s,this.testClassMap=new t,this.resultListener=e,this.objectProvider=n}addTest(t){if(!(t.testFunctions&&t.testFunctions()instanceof s))throw"A static function called 'testFunctions' must be provided in "+t.name+" which returns a List all the test functions in "+t.name+".prototype";return t.testFunctions().forEach(((s,e)=>{if(!s)throw t.name+".testFunctions() refers to missing functions";return!0}),this),this.testClassMap.set(t.name,t),this}contains(t){return this.testClassMap.contains(t.name)}async runAll(){e.listener=this.logListener;let t=new a(this.testClassMap,this.objectProvider,this.resultListener);try{return await this.testClassMap.promiseChain(o.run,t),o.close(t),t}catch(t){throw t}}async runClass(t){e.listener=this.logListener;let s=this.testClassMap.get(t),r=new a(this.testClassMap,this.objectProvider,this.resultListener);try{return await o.run(t,s,r),o.close(r),r}catch(t){throw t}}async runFunction(t,s){e.listener=this.logListener;let r=this.testClassMap.get(t),n=new a(this.testClassMap,this.objectProvider,this.resultListener);try{return await o.run(t,r,n,s),o.close(n),n}catch(t){throw t}}static run(t,s,e,r=null){return o.printHeader(s.name),o.runFunctionsByClass(s,e,r)}static filter(t,s){return s?t.filter((t=>t===s)):t}static async loadObjectByClass(t,s){if(s.testObjectMap.contains(t.name))return s;try{const e=await s.objectProvider.provide(t);return s.testObjectMap.set(t.name,e),s}catch(t){throw new Error(t)}}static async runFunctionsByClass(t,s,e){const r=t.testFunctions();await r.promiseChain((r=>e&&r.name!==e?Promise.resolve():o.runFunction(t,r,s)),s)}static async runFunction(t,s,e){o.callResultListener(e,i.RUNNING,t,s),await o.loadObjectByClass(t,e);const r=e.testObjectMap.get(t.name);let n=null;try{n=s.call(r)}catch(r){o.reportFailure(t,s,r,e)}if(n instanceof Promise)try{await n,o.reportSuccess(t,s,e)}catch(r){o.reportFailure(t,s,r,e)}else o.reportSuccess(t,s,e)}static reportFailure(t,s,e,r){o.addFail(t,s,r),o.callResultListener(r,i.FAIL,t,s),c.error(o.signature(t,s)+" failed. Reason:"),c.error(e),c.error("")}static reportSuccess(t,s,e){o.addSuccess(t,s,e),o.callResultListener(e,i.SUCCESS,t,s)}static callResultListener(t,s,e,r){t.resultListener&&t.resultListener.call(new i(s,e.name,r?r.name:null))}static addSuccess(t,s,e){e.runSuccessTestList.add(o.signature(t,s))}static addFail(t,s,e){e.runFailTestList.add(o.signature(t,s))}static signature(t,s){return t.name+"."+s.name+"()"}static close(t){try{o.printReport(t)}finally{e.clearListener()}}static printHeader(t){const s="#  Running test: "+t+"  #";let e="";for(let t=0;t<s.length;t++)e+="#";c.info(e),c.info(s),c.info(e),c.info("")}static printReport(t){c.info("###################"),c.info("#   Test Report   #"),c.info("###################"),c.info("");let s=0;t.runSuccessTestList.size()>0&&(c.info("Succeeded:"),t.runSuccessTestList.forEach(((t,e)=>(c.info(s+++". "+t),!0))),c.info(""));let e=0;if(t.runFailTestList.size()>0&&(c.info("Failed:"),t.runFailTestList.forEach(((t,s)=>(c.info(e+++". "+t),!0))),c.info("")),0!=e)throw t.runFailTestList.size()+" Tests failed"}}class l{static assertEquals(t,s){if(t!==s)throw"String Assertion Failed. Expected: '"+t+"' Actual: '"+s+"'"}}class u{static assertTrue(t=!0){if(!t)throw"Boolean assertion failed. Expected true but was "+t}}export{u as AssertBoolean,l as AssertString,r as ObjectProvider,o as TestBench,i as TestClassState,a as TestExecutionContext,n as TestTrigger};
